{"version":3,"sources":["../src/shared/createClient.ts","../src/shared/utils/buildMetafieldIdentifiers.ts","../src/shared/utils/camelizeKeys.ts","../src/shared/utils/parseStringifiedArray.ts","../src/shared/utils/castMetafieldValue.ts","../src/shared/utils/renderRichText.ts","../src/shared/utils/castMetafields.ts","../src/shared/utils/safeParseArray.ts","../src/shared/utils/formatAvailableFilters.ts","../src/shared/utils/normalizeMetafields.ts","../src/shared/graphql/getProductById.ts","../src/shared/graphql/getProductByHandle.ts","../src/core/getProduct.ts","../src/shared/graphql/getCollectionProducts.ts","../src/core/getCollection.ts","../src/core/createBaseClient.ts"],"sourcesContent":["export interface ShopifyClientConfig {\n  shop: string;\n  token: string;\n  apiVersion?: string;\n}\n\nexport function createSharedShopify(config: ShopifyClientConfig) {\n  const apiVersion = config.apiVersion || \"2025-01\";\n  const endpoint = `https://${config.shop}/api/${apiVersion}/graphql.json`;\n\n  async function fetchShopify<T = any>(\n    query: string,\n    variables: Record<string, any> = {}\n  ): Promise<T> {\n    const res = await fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Shopify-Storefront-Access-Token\": config.token,\n      },\n      body: JSON.stringify({ query, variables }),\n    });\n\n    const json = await res.json();\n\n    if (json.errors) {\n      throw new Error(json.errors[0]?.message || \"Shopify GraphQL error\");\n    }\n\n    return json;\n  }\n\n  return {\n    fetchShopify,\n  };\n}\n","import { CustomMetafieldDefinition } from \"@t/metafields\";\n\nexport function buildMetafieldIdentifiers(\n  metafields: CustomMetafieldDefinition[]\n): string {\n  return metafields\n    .map(({ field }) => {\n      const [namespace, key] = field.split(\".\");\n      return `{ namespace: \"${namespace}\", key: \"${key}\" }`;\n    })\n    .join(\",\\n\");\n}\n","import { camelCase } from \"lodash-es\";\n\nexport function camelizeMetafields(obj: any): any {\n  if (Array.isArray(obj)) {\n    return obj.map(camelizeMetafields);\n  }\n\n  if (obj !== null && typeof obj === \"object\") {\n    return Object.fromEntries(\n      Object.entries(obj).map(([key, value]) => [\n        camelCase(key),\n        camelizeMetafields(value),\n      ])\n    );\n  }\n\n  // Don't transform strings or primitives\n  return obj;\n}\n","export function parseStringifiedArray(value: string): string[] | string {\n  try {\n    const parsed = JSON.parse(value);\n    return Array.isArray(parsed) ? parsed : value;\n  } catch {\n    return value;\n  }\n}\n","import { ShopifyCustomFieldType } from \"@t/metafields\";\nimport { parseStringifiedArray } from \"@utils/parseStringifiedArray\";\n\nexport function castMetafieldValue(\n  rawValue: string,\n  type: ShopifyCustomFieldType\n): unknown {\n  switch (type) {\n    case \"integer\":\n    case \"decimal\":\n    case \"money\":\n    case \"rating\":\n    case \"weight\":\n    case \"volume\":\n    case \"dimension\":\n      return Number(rawValue);\n\n    case \"true_false\":\n      return rawValue === \"true\";\n\n    case \"json\":\n      try {\n        return JSON.parse(rawValue);\n      } catch {\n        return rawValue; // fallback to raw string if invalid\n      }\n\n    case \"date\":\n    case \"date_and_time\":\n      return new Date(rawValue); // returns a JS Date object\n\n    case \"color\":\n    case \"url\":\n    case \"id\":\n    case \"single_line_text\":\n    case \"multi_line_text\":\n    case \"rich_text\":\n      return rawValue;\n\n    case \"Product\":\n    case \"Product_variant\":\n    case \"Customer\":\n    case \"Company\":\n    case \"Page\":\n    case \"Collection\":\n    case \"File\":\n    case \"Metaobject\":\n      return parseStringifiedArray(rawValue);\n\n    default:\n      return rawValue;\n  }\n}\n","/**\n * Converts Shopify rich_text schema (JSON) to HTML.\n *\n * @param schema - The rich text schema object or JSON string.\n * @param options - Conversion options.\n * @param options.scoped - A string for a CSS class name or `true` to use the default (\"rte\").\n * @param options.classes - Optional mapping of tag names to CSS class names.\n * @param options.newLineToBreak - If true, converts newlines in plain text to <br>.\n * @returns The resulting HTML string.\n */\nexport function renderRichText(\n  schema: any,\n  options: {\n    scoped?: string | boolean;\n    classes?: Record<string, string>;\n    newLineToBreak?: boolean;\n  } = {}\n): string {\n  let { scoped, classes, newLineToBreak } = options;\n  let html = \"\";\n\n  // If schema is a JSON string, parse it.\n  if (typeof schema === \"string\") {\n    try {\n      schema = JSON.parse(schema);\n    } catch (error) {\n      console.error(\"Error parsing rich text schema:\", error);\n      return schema; // fallback: return the original string\n    }\n  }\n\n  // Allow options itself to be provided as a simple value for scoped\n  if (typeof options === \"string\" || typeof options === \"boolean\") {\n    scoped = options;\n  }\n\n  // If schema is the root object with children\n  if (\n    schema &&\n    schema.type === \"root\" &&\n    Array.isArray(schema.children) &&\n    schema.children.length > 0\n  ) {\n    if (scoped) {\n      const className = scoped === true ? \"rte\" : scoped;\n      html += `<div class=\"${className}\">${renderRichText(\n        schema.children,\n        options\n      )}</div>`;\n    } else {\n      html += renderRichText(schema.children, options);\n    }\n  } else if (Array.isArray(schema)) {\n    // Iterate over each element in the array\n    for (const el of schema) {\n      switch (el.type) {\n        case \"paragraph\":\n          html += buildParagraph(el, options);\n          break;\n        case \"heading\":\n          html += buildHeading(el, options);\n          break;\n        case \"list\":\n          html += buildList(el, options);\n          break;\n        case \"list-item\":\n          html += buildListItem(el, options);\n          break;\n        case \"link\":\n          html += buildLink(el, options);\n          break;\n        case \"text\":\n          html += buildText(el, options);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return html;\n}\n\nfunction getClass(\n  tag: string,\n  classes?: Record<string, string>\n): string | null {\n  if (classes && classes[tag]) {\n    return classes[tag];\n  }\n  return null;\n}\n\nfunction outputAttributes(attributes: Record<string, any>): string {\n  if (!attributes) return \"\";\n  return Object.keys(attributes)\n    .filter((key) => attributes[key])\n    .map((key) => ` ${key}=\"${attributes[key]}\"`)\n    .join(\"\");\n}\n\nfunction createElement(\n  tag: string,\n  classes: Record<string, string> | undefined,\n  content: string,\n  attributes: Record<string, any> = {}\n): string {\n  const className = getClass(tag, classes);\n  if (className) {\n    attributes = { ...attributes, class: className };\n  }\n  return `<${tag}${outputAttributes(attributes)}>${content}</${tag}>`;\n}\n\nfunction buildParagraph(el: any, options: any): string {\n  const { classes } = options;\n  return createElement(\"p\", classes, renderRichText(el?.children, options));\n}\n\nfunction buildHeading(el: any, options: any): string {\n  const { classes } = options;\n  const tag = `h${el?.level || 1}`;\n  return createElement(tag, classes, renderRichText(el?.children, options));\n}\n\nfunction buildList(el: any, options: any): string {\n  const { classes } = options;\n  const tag = el?.listType === \"ordered\" ? \"ol\" : \"ul\";\n  return createElement(tag, classes, renderRichText(el?.children, options));\n}\n\nfunction buildListItem(el: any, options: any): string {\n  const { classes } = options;\n  return createElement(\"li\", classes, renderRichText(el?.children, options));\n}\n\nfunction buildLink(el: any, options: any): string {\n  const { classes } = options;\n  const attributes = {\n    href: el?.url,\n    title: el?.title,\n    target: el?.target,\n  };\n  return createElement(\n    \"a\",\n    classes,\n    renderRichText(el?.children, options),\n    attributes\n  );\n}\n\nfunction buildText(el: any, options: any): string {\n  const { classes, newLineToBreak } = options;\n  if (el?.bold && el?.italic) {\n    return createElement(\n      \"strong\",\n      classes,\n      createElement(\"em\", classes, el?.value)\n    );\n  } else if (el?.bold) {\n    return createElement(\"strong\", classes, el?.value);\n  } else if (el?.italic) {\n    return createElement(\"em\", classes, el?.value);\n  } else {\n    return newLineToBreak\n      ? el?.value?.replace(/\\n/g, \"<br>\") || \"\"\n      : el?.value || \"\";\n  }\n}\n","import {\n  CustomMetafieldDefinition,\n  ResolvedMetafieldInfo,\n} from \"@t/metafields\";\nimport { castMetafieldValue } from \"./castMetafieldValue\";\nimport { renderRichText } from \"./renderRichText\";\n\n/**\n * Casts normalized metafields to their correct types.\n * @param normalizedMetafields - Output from normalizeMetafields (nested by namespace).\n * @param definitions - Array of custom metafield definitions.\n * @param renderRichTextAsHtml - If true, rich_text fields are rendered as HTML.\n * @param transformMetafields - Optional post-processing function.\n * @param resolveFiles - Whether to resolve File GIDs into file objects.\n * @param fetchShopify - Required for resolving File types.\n * @returns A nested object with properly cast metafield values.\n */\nexport async function castMetafields(\n  normalizedMetafields: Record<string, Record<string, string>>,\n  definitions: CustomMetafieldDefinition[],\n  renderRichTextAsHtml: boolean,\n  transformMetafields?: (\n    raw: Record<string, Record<string, string>>,\n    casted: Record<string, any>,\n    definitions: ResolvedMetafieldInfo[]\n  ) => Record<string, any> | Promise<Record<string, any>>,\n  resolveFiles: boolean = false,\n  fetchShopify?: (\n    query: string,\n    variables?: Record<string, any>\n  ) => Promise<any>\n): Promise<Record<string, any>> {\n  const result: Record<string, any> = {};\n  const resolvedDefs: ResolvedMetafieldInfo[] = [];\n  const fileGIDs: string[] = [];\n\n  for (const def of definitions) {\n    const [namespace, key] = def.field.split(\".\");\n    const rawValue = normalizedMetafields?.[namespace]?.[key];\n\n    resolvedDefs.push({\n      namespace,\n      key,\n      fullKey: def.field,\n      type: def.type,\n    });\n\n    if (rawValue === undefined) continue;\n    result[namespace] = result[namespace] || {};\n\n    // Rich text HTML\n    if (def.type === \"rich_text\" && renderRichTextAsHtml) {\n      result[namespace][key] = renderRichText(rawValue);\n      continue;\n    }\n\n    // File types\n    if (def.type === \"File\" && resolveFiles) {\n      const casted = castMetafieldValue(rawValue, def.type);\n\n      if (Array.isArray(casted)) {\n        fileGIDs.push(...casted);\n      } else if (typeof casted === \"string\") {\n        fileGIDs.push(casted);\n      }\n\n      result[namespace][key] = casted;\n      continue;\n    }\n\n    // All other types\n    result[namespace][key] = castMetafieldValue(rawValue, def.type);\n  }\n\n  // ðŸ§© Resolve File GIDs to actual file objects\n  if (resolveFiles && fileGIDs.length > 0 && fetchShopify) {\n    const { resolveShopifyFiles } = await import(\"./resolveShopifyFiles\");\n    const fileMap = await resolveShopifyFiles(fileGIDs, fetchShopify);\n\n    for (const def of definitions) {\n      if (def.type !== \"File\") continue;\n      const [namespace, key] = def.field.split(\".\");\n      const raw = result[namespace]?.[key];\n\n      if (Array.isArray(raw)) {\n        result[namespace][key] = raw.map((gid: string) => fileMap[gid] || gid);\n      } else if (typeof raw === \"string\") {\n        result[namespace][key] = fileMap[raw] || raw;\n      }\n    }\n  }\n\n  // ðŸ§  Final transformation\n  if (typeof transformMetafields === \"function\") {\n    return transformMetafields(normalizedMetafields, result, resolvedDefs);\n  }\n\n  return result;\n}\n","export function safeParseArray<T = any>(value: T[] | null | undefined): T[] {\n  return Array.isArray(value) ? value : [];\n}\n","import { FilterGroup } from \"@t/products\";\nimport { safeParseArray } from \"@utils/safeParseArray\";\n\nexport function formatAvailableFilters(rawFilters: any[]): FilterGroup[] {\n  return rawFilters.map((group) => ({\n    id: group.id,\n    label: group.label,\n    values: safeParseArray(group.values).map((value: any) => ({\n      id: value.id,\n      label: value.label,\n      count: value.count,\n    })),\n  }));\n}\n","import { CustomMetafieldDefinition } from \"@t/metafields\";\n\ntype Metafield = { key: string; value: string };\n\nexport function normalizeMetafields(\n  metafields: (Metafield | null)[],\n  definitions: CustomMetafieldDefinition[]\n): Record<string, any> {\n  const result: Record<string, any> = {};\n\n  // Build a map from key â†’ namespace based on definitions\n  const keyToNamespace = new Map<string, string>();\n  for (const def of definitions) {\n    const [namespace, key] = def.field.split(\".\");\n    keyToNamespace.set(key, namespace);\n  }\n\n  for (const field of metafields) {\n    if (!field?.key) continue;\n\n    const key = field.key;\n    const namespace = keyToNamespace.get(key) || \"global\";\n\n    if (!result[namespace]) {\n      result[namespace] = {};\n    }\n\n    result[namespace][key] = field.value;\n  }\n\n  return result;\n}\n","export const getProductByIdQuery = (\n  productMetafieldIdentifiers: string,\n  variantMetafieldIdentifiers: string\n) => `\n  query getProductById($id: ID!) {\n    node(id: $id) {\n      ... on Product {\n        id\n        title\n        handle\n        descriptionHtml\n        featuredImage {\n          originalSrc\n          altText\n        }\n        images(first: 10) {\n          edges {\n            node {\n              originalSrc\n              altText\n            }\n          }\n        }\n        variants(first: 10) {\n          edges {\n            node {\n              id\n              title\n              priceV2 { amount, currencyCode }\n              compareAtPriceV2 { amount, currencyCode }\n              product { title, handle }\n              metafields(identifiers: [${variantMetafieldIdentifiers}]) {\n                key\n                value\n              }\n            }\n          }\n        }\n        metafields(identifiers: [${productMetafieldIdentifiers}]) {\n          key\n          value\n        }\n      }\n    }\n  }\n`;\n","export const getProductByHandleQuery = (\n  productMetafieldIdentifiers: string,\n  variantMetafieldIdentifiers: string\n) => `\n  query getProductByHandle($handle: String!) {\n    productByHandle(handle: $handle) {\n      id\n      title\n      handle\n      descriptionHtml\n      featuredImage {\n        originalSrc\n        altText\n      }\n      images(first: 10) {\n        edges {\n          node {\n            originalSrc\n            altText\n          }\n        }\n      }\n      variants(first: 10) {\n        edges {\n          node {\n            id\n            title\n            priceV2 { amount, currencyCode }\n            compareAtPriceV2 { amount, currencyCode }\n            product { title, handle }\n            metafields(identifiers: [${variantMetafieldIdentifiers}]) {\n              key\n              value\n            }\n          }\n        }\n      }\n      metafields(identifiers: [${productMetafieldIdentifiers}]) {\n        key\n        value\n      }\n    }\n  }\n`;\n","import { ImageEdge } from \"@t/edges\";\nimport { FetchShopify } from \"@t/fetch\";\nimport {\n  Product,\n  VariantEdge,\n  FetchProductResult,\n  GetProductOptions,\n  Variant,\n} from \"@t/product\";\nimport {\n  castMetafields,\n  safeParseArray,\n  camelizeMetafields,\n  normalizeMetafields,\n  buildMetafieldIdentifiers,\n} from \"@utils\";\nimport { getProductByIdQuery } from \"@graphql/getProductById\";\nimport { getProductByHandleQuery } from \"@graphql/getProductByHandle\";\n\nexport async function getProduct(\n  fetchShopify: FetchShopify,\n  options: GetProductOptions\n): Promise<FetchProductResult> {\n  const {\n    handle,\n    id,\n    customMetafields = [],\n    variantMetafields = [],\n    options: settings,\n  } = options;\n\n  const {\n    locale,\n    renderRichTextAsHtml = false,\n    camelizeKeys = true,\n    resolveFiles = true,\n    transformMetafields,\n    transformVariantMetafields,\n  } = settings;\n\n  if (!handle && !id) {\n    return { data: null, error: \"Either handle or id must be provided\" };\n  }\n\n  const productMetafieldIdentifiers =\n    customMetafields.length > 0\n      ? buildMetafieldIdentifiers(customMetafields)\n      : \"\";\n\n  const variantMetafieldIdentifiers =\n    variantMetafields.length > 0\n      ? buildMetafieldIdentifiers(variantMetafields)\n      : \"\";\n\n  const query = id\n    ? getProductByIdQuery(\n        productMetafieldIdentifiers,\n        variantMetafieldIdentifiers\n      )\n    : getProductByHandleQuery(\n        productMetafieldIdentifiers,\n        variantMetafieldIdentifiers\n      );\n\n  const variables = id ? { id } : { handle, locale };\n\n  try {\n    const json = await fetchShopify(query, variables);\n\n    if (json.errors?.length) {\n      return {\n        data: null,\n        error: json.errors[0]?.message || \"GraphQL error\",\n      };\n    }\n\n    const node = id ? json.data?.node : json.data?.productByHandle;\n    if (!node) {\n      return { data: null, error: \"Product not found\" };\n    }\n\n    const rawMetafields = normalizeMetafields(\n      node.metafields || [],\n      customMetafields\n    );\n\n    const castedMetafields =\n      customMetafields.length > 0\n        ? await castMetafields(\n            rawMetafields,\n            customMetafields,\n            renderRichTextAsHtml,\n            transformMetafields,\n            resolveFiles,\n            fetchShopify\n          )\n        : rawMetafields;\n\n    const metafields =\n      camelizeKeys !== false\n        ? camelizeMetafields(castedMetafields)\n        : castedMetafields;\n\n    const images = safeParseArray<ImageEdge>(node.images?.edges).map(\n      (edge) => ({\n        originalSrc: edge.node.originalSrc,\n        altText: edge.node.altText ?? null,\n      })\n    );\n\n    const variants: Variant[] = await Promise.all(\n      safeParseArray<VariantEdge>(node.variants?.edges).map(async (edge) => {\n        const variant = edge.node;\n\n        const rawVariantMetafields = normalizeMetafields(\n          variant.metafields || [],\n          variantMetafields\n        );\n\n        const castedVariantMetafields =\n          variantMetafields.length > 0\n            ? await castMetafields(\n                rawVariantMetafields,\n                variantMetafields,\n                renderRichTextAsHtml,\n                transformVariantMetafields,\n                resolveFiles,\n                fetchShopify\n              )\n            : rawVariantMetafields;\n\n        const finalVariantMetafields =\n          camelizeKeys !== false\n            ? camelizeMetafields(castedVariantMetafields)\n            : castedVariantMetafields;\n\n        return {\n          id: variant.id,\n          productTitle: variant.product?.title || node.title,\n          variantTitle:\n            variant.title === \"Default Title\" ? node.title : variant.title,\n          price: {\n            amount: parseFloat(variant.priceV2.amount),\n            currencyCode: variant.priceV2.currencyCode,\n          },\n          compareAtPrice: variant.compareAtPriceV2\n            ? {\n                amount: parseFloat(variant.compareAtPriceV2.amount),\n                currencyCode: variant.compareAtPriceV2.currencyCode,\n              }\n            : null,\n          metafields: finalVariantMetafields,\n        };\n      })\n    );\n\n    const defaultPrice = variants[0]?.price ?? {\n      amount: 0,\n      currencyCode: \"EUR\",\n    };\n\n    const defaultCompareAtPrice = variants[0]?.compareAtPrice ?? null;\n\n    const product: Product = {\n      id: node.id,\n      title: node.title,\n      handle: node.handle,\n      descriptionHtml: node.descriptionHtml || \"\",\n      featuredImage: node.featuredImage || null,\n      images,\n      variants,\n      price: defaultPrice,\n      compareAtPrice: defaultCompareAtPrice,\n      metafields,\n    };\n\n    return { data: product, error: null };\n  } catch (err) {\n    return {\n      data: null,\n      error: err instanceof Error ? err.message : \"Unexpected error\",\n    };\n  }\n}\n","export function getCollectionProductsQuery(\n  limit: number,\n  productMetafieldIdentifiers: string,\n  hasFilters: boolean,\n  variantMetafieldIdentifiers: string,\n  collectionMetafieldIdentifiers: string,\n  includeProducts: boolean // âœ… new param\n): string {\n  return `\n    query getCollectionProducts(\n      $handle: String!,\n      $cursor: String,\n      ${hasFilters ? \"$filters: [ProductFilter!],\" : \"\"}\n      $sortKey: ProductCollectionSortKeys,\n      $reverse: Boolean\n    ) {\n      collection(handle: $handle) {\n        id\n        title\n        handle\n        metafields(identifiers: [${collectionMetafieldIdentifiers}]) {\n          namespace\n          key\n          value\n          type\n        }\n        ${includeProducts ? `\n        products(\n          first: ${limit},\n          after: $cursor,\n          sortKey: $sortKey,\n          reverse: $reverse\n          ${hasFilters ? \"filters: $filters,\" : \"\"}\n        ) {\n          pageInfo {\n            hasNextPage\n            hasPreviousPage\n            startCursor\n            endCursor\n          }\n          filters {\n            id\n            label\n            values {\n              id\n              label\n              count\n            }\n          }\n          edges {\n            node {\n              id\n              title\n              handle\n              descriptionHtml\n              featuredImage {\n                originalSrc\n                altText\n              }\n              images(first: 10) {\n                edges {\n                  node {\n                    originalSrc\n                    altText\n                  }\n                }\n              }\n              variants(first: 10) {\n                edges {\n                  node {\n                    id\n                    title\n                    priceV2 { amount currencyCode }\n                    compareAtPriceV2 { amount currencyCode }\n                    product { title handle }\n                    metafields(identifiers: [${variantMetafieldIdentifiers}]) {\n                      key\n                      value\n                    }\n                  }\n                }\n              }\n              metafields(identifiers: [${productMetafieldIdentifiers}]) {\n                key\n                value\n              }\n            }\n          }\n        }\n        ` : \"\"}\n      }\n    }\n  `;\n}\n","\nimport { FetchShopify } from \"@t/fetch\";\nimport { Product, Variant, VariantEdge } from \"@t/product\";\n\nimport {\n  castMetafields,\n  safeParseArray,\n  camelizeMetafields,\n  normalizeMetafields,\n  buildMetafieldIdentifiers,\n  formatAvailableFilters,\n} from \"@utils\";\n\nimport { getCollectionProductsQuery } from \"@graphql/getCollectionProducts\";\nimport { FilterGroup, GetCollectionOptions, FetchCollectionResult, ProductsPageInfo } from \"@t/collections\";\n\nexport async function getCollection(\n  fetchShopify: FetchShopify,\n  config: GetCollectionOptions\n): Promise<FetchCollectionResult> {\n  const {\n    collectionHandle,\n    includeProducts = false,\n    limit = 12,\n    cursor,\n    reverse = false,\n    sortKey = \"RELEVANCE\",\n    filters = [],\n    productMetafields = [],\n    collectionMetafields = [],\n    variantMetafields = [],\n    options: {\n      resolveFiles = true,\n      renderRichTextAsHtml = false,\n      transformCollectionMetafields,\n      transformProductMetafields,\n      transformVariantMetafields,\n      camelizeKeys = true,\n    } = {},\n  } = config;\n\n  const productMetafieldIdentifiers = productMetafields.length > 0\n    ? buildMetafieldIdentifiers(productMetafields)\n    : \"\";\n  const variantMetafieldIdentifiers = variantMetafields.length > 0\n    ? buildMetafieldIdentifiers(variantMetafields)\n    : \"\";\n  const collectionMetafieldIdentifiers = collectionMetafields.length > 0\n    ? buildMetafieldIdentifiers(collectionMetafields)\n    : \"\";\n\n  const query = getCollectionProductsQuery(\n    limit,\n    productMetafieldIdentifiers,\n    filters.length > 0,\n    variantMetafieldIdentifiers,\n    collectionMetafieldIdentifiers,\n    includeProducts\n  );\n\n  const variables = {\n    handle: collectionHandle,\n    cursor,\n    reverse,\n    sortKey,\n    filters,\n  };\n\n  try {\n    const json = await fetchShopify(query, variables);\n    const collection = json.data?.collection;\n\n    if (!collection) {\n      return {\n        data: [],\n        pageInfo: null,\n        error: \"Collection not found\",\n        collectionMetafields: {},\n      };\n    }\n\n    let resolvedCollectionMetafields: Record<string, any> = {};\n    if (collection.metafields) {\n      const raw = normalizeMetafields(collection.metafields, collectionMetafields);\n      const casted = await castMetafields(\n        raw,\n        collectionMetafields,\n        renderRichTextAsHtml,\n        transformCollectionMetafields,\n        resolveFiles,\n        fetchShopify\n      );\n      resolvedCollectionMetafields = camelizeKeys ? camelizeMetafields(casted) : casted;\n    }\n\n    if (!includeProducts) {\n      return {\n        data: [],\n        pageInfo: null,\n        availableFilters: [],\n        collectionMetafields: resolvedCollectionMetafields,\n        error: null,\n      };\n    }\n\n    const edges = safeParseArray(collection.products.edges);\n    const products: Product[] = [];\n\n    for (const edge of edges) {\n      const node = edge.node;\n\n      const rawProductMetafields = normalizeMetafields(\n        node.metafields || [],\n        productMetafields\n      );\n      const castedProductMetafields = productMetafields.length > 0\n        ? await castMetafields(\n          rawProductMetafields,\n          productMetafields,\n          renderRichTextAsHtml,\n          transformProductMetafields,\n          resolveFiles,\n          fetchShopify\n        )\n        : rawProductMetafields;\n      const metafields = camelizeKeys\n        ? camelizeMetafields(castedProductMetafields)\n        : castedProductMetafields;\n\n      const variants: Variant[] = await Promise.all(\n        safeParseArray<VariantEdge>(node.variants?.edges).map(async (edge) => {\n          const variant = edge.node;\n\n          const rawVariantMetafields = normalizeMetafields(\n            variant.metafields || [],\n            variantMetafields\n          );\n          const castedVariantMetafields = variantMetafields.length > 0\n            ? await castMetafields(\n              rawVariantMetafields,\n              variantMetafields,\n              renderRichTextAsHtml,\n              transformVariantMetafields,\n              resolveFiles,\n              fetchShopify\n            )\n            : rawVariantMetafields;\n          const finalVariantMetafields = camelizeKeys\n            ? camelizeMetafields(castedVariantMetafields)\n            : castedVariantMetafields;\n\n          return {\n            id: variant.id,\n            productTitle: variant.product?.title || node.title,\n            variantTitle:\n              variant.title === \"Default Title\" ? node.title : variant.title,\n            price: {\n              amount: parseFloat(variant.priceV2.amount),\n              currencyCode: variant.priceV2.currencyCode,\n            },\n            compareAtPrice: variant.compareAtPriceV2\n              ? {\n                amount: parseFloat(variant.compareAtPriceV2.amount),\n                currencyCode: variant.compareAtPriceV2.currencyCode,\n              }\n              : null,\n            metafields: finalVariantMetafields,\n          };\n        })\n      );\n\n      const product: Product = {\n        id: node.id,\n        title: node.title,\n        handle: node.handle,\n        descriptionHtml: node.descriptionHtml || \"\",\n        featuredImage: node.featuredImage || null,\n        images: safeParseArray(node.images?.edges).map((edge) => edge.node),\n        variants,\n        price: {\n          amount: variants[0]?.price?.amount,\n          currencyCode: variants[0]?.price?.currencyCode,\n        },\n        compareAtPrice: variants[0]?.compareAtPrice\n          ? {\n            amount: variants[0].compareAtPrice.amount,\n            currencyCode: variants[0].compareAtPrice.currencyCode,\n          }\n          : null,\n        metafields,\n      };\n\n      products.push(product);\n    }\n\n    const pageInfo: ProductsPageInfo = collection.products.pageInfo;\n    const rawFilters = collection.products.filters || [];\n    const availableFilters: FilterGroup[] = formatAvailableFilters(rawFilters);\n\n    return {\n      data: products,\n      pageInfo,\n      availableFilters,\n      collectionMetafields: resolvedCollectionMetafields,\n      error: null,\n    };\n  } catch (error) {\n    return {\n      data: [],\n      pageInfo: {\n        hasNextPage: false,\n        hasPreviousPage: false,\n        endCursor: null,\n        startCursor: null,\n      },\n      error: error instanceof Error ? error.message : \"Unexpected error\",\n      collectionMetafields: {},\n    };\n  }\n}","import { createSharedShopify, ShopifyClientConfig } from \"../shared/createClient\";\nimport { getProduct } from \"@core/getProduct\";\nimport { getCollection } from \"@core/getCollection\";\nimport { GetProductOptions } from \"@t/product\";\nimport { GetCollectionOptions } from \"@t/collections\";\n\nexport function createShopifyClient(config: ShopifyClientConfig) {\n  const { fetchShopify } = createSharedShopify(config);\n\n  return {\n    fetchShopify,\n    getProduct: (args: GetProductOptions) => getProduct(fetchShopify, args),\n    getCollection: (args: GetCollectionOptions) => getCollection(fetchShopify, args),\n  };\n}\n"],"mappings":"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","names":["edge"]}